# 强连通分量

在一张有向图中，如果两个节点能够互相到达，我们称它们为 **强连通**。
我们规定，一个结点和它自己是强连通的。
如果一个有向图满足它的任何两个节点都是强连通的，
那么这个有向图就是一个 **强连通图**。

给定任何一个有向图，我们可以把它分割成一个个强连通子图。
在所有的分割方案中，我们希望保留所有的强连通关系：
如果两个结点在原图中强连通，我们希望分割后，这两个结点也是强连通的。
这种分割产生的强连通子图就称为原有向图的 **强连通分量** (Strongly Connected Compoenet)。

值得注意的是，分割后的强连通子图不会相交。
如果存在节点同时在两张强连通子图中，
我们很容易证明这两张强连通子图的并集也是强连通的，
换句话说就是，它们起始是一张强连通子图。

## Kosaraju 算法

> 因为这一节的内容完全是从另一篇博客中参考来的，还没有内化成我的东西，所以我把引用放在了这一小节的开头，避免误会发生。
> [Kosaragu算法的证明](http://edward-mj.com/archives/455)。

首先介绍一下算法的流程：

1. 输入一张有向图 $G$，它可以是邻接矩阵，也可以是邻接表。
2. 我们首先会构造一张反向有向图 $G^T$，将原有向图的箭头方向反向。
    $G$ 如果是邻接矩阵的形式，那么我们不需要特别构造 $G^T$，
    但是如果 $G$ 是邻接表形式，我们需要特别构造 $G^T$。
3. 接着使用多次使用 dfs 策略来搜索原图 $G$，以节点 **访问结束的顺序** 将节点压入一个栈，直到所有的节点被访问。
4. 将栈的元素依次弹出，如果弹出的节点 $n$ 未被访问第二次（第一次发生在第3步，也就是第四步中没有访问过它），
    就使用 dfs 策略以节点 $n$ 为起点，搜索反转图 $G^T$。
    每次 dfs 策略访问到的节点组成一个原图 $G$ 的强连通分量。

这个算法第一次看不是那么直觉，需要一点证明。

!!!命题
    **Kosaraju 算法的第4步中构造的子图一定是强连通子图**。

!!!证明
    首先，设我们在第4步中，我们通过对 $G^T$ dfs 先后访问了节点 $\mathbf{x}$ 和 $\mathbf{y}$，
    并且 $\mathbf{x}$ 是 dfs 的起点。
    那么在 $G^T$ 中，存在一条从 $\mathbf{x}$ 到 $\mathbf{y}$ 的路径，
    也就是说原图 $G$ 中存在一条从 $\mathbf{y}$ 到 $\mathbf{x}$ 的路径。

    又因为 $\mathbf{x}$ 是 dfs 的起点，
    所以在第三步构造的栈中，$\mathbf{x}$ 是高于 $\mathbf{y}$ 的，
    也就是说 $\mathbf{y}$ 早一步被压入栈中。

    我们回过头来研究算法的第3步，什么时候 $\mathbf{y}$ 会被早一步压入栈中？
    首先我们可以肯定，以 $\mathbf{y}$ 为起点深度搜索原图 $G$ 的时候，$\mathbf{x}$ 还不在栈中。
    $\mathbf{x}$ 不在栈中的可能性有两个：

    - $\mathbf{x}$ 压根还没有被考虑到；
    - $\mathbf{x}$ 为起点 $dfs$ 搜索到了 $\mathbf{y}$。

    其中因为原图中存在一条从 $\mathbf{y}$ 到 $\mathbf{x}$ 的路径，如果 $\mathbf{x}$ 压根没有被考虑到，那么以 $\mathbf{y}$ 为根的dfs时必然会搜索到 $\mathbf{x}$，那么 $\mathbf{x}$ 会被早压入栈中，又产生了矛盾。所以一定是 $\mathbf{x}$ 为起点 $dfs$ 搜索到了 $\mathbf{y}$，也就是原图存在一条从 $\mathbf{x}$ 到 $\mathbf{y}$ 的路径。
    
    综上，第4步生成的子图满足起点 $\mathbf{x}$ 与其他节点强连通，进一步可得它是强连通子图。

!!!命题
    **Kosaraju 算法的第4步中构造的强连通子图是原图的强连通分量**。

!!!证明
    对于任意两个强连通节点 $\mathbf{x}$ 和 $\mathbf{y}$，在第4步中，两个节点中一定会有一个节点先被dfs访问。
    又由于两个节点是强连通的，所以从先被访问的的节点dfs一定会访问到另一个节点，在第4步中，意味着它们一定被放到了同一个强连通子图中。

我们综合上面两个结论，我们可以证明 Tosaraju 算法的正确性。

Tosaraju 算法使用了两轮dfs，它的时间复杂度为 $O(m + n)$ 其中 $m$ 为边的数目，$n$ 为节点的数目。
而另一个求最大连通分量的算法 Tarjan 只需要执行一轮dfs。
不过 Tosaraju 算法有一个非常好的性质而 Tarjan 算法没有。

!!!命题
    Tosaraju算法求出来的强连通分量已经是 **拓扑排序** 的。

!!!证明
    设Tosaraju先后生成了两个强连通分量 $A$ 和 $B$，
    并且设 $A$ 中最接近栈顶的元素是 $a_0$，以及 $B$ 中最接近栈顶的元素是 $b_0$。
    根据 $A$ 和 $B$ 生成的先后顺序可得 $a_0$ 比 $b_0$ 更接近栈顶。
    
    这里只会有两种情况导致 $a_0$ 比 $b_0$ 更接近栈顶：

    - 在 Tosaraju 算法的第三步中，我们先访问到了 $B$ 但是在对 $B$ 进行 dfs 时没有访问到 $A$, 这种情况暗示没有路径从 $B$ 到 $A$;
    - 在 Tosaraju 算法的第三步中，我们先访问到了 $A$ 但是在对 $A$ 进行 dfs 时访问到了 $B$，这种情况按时存在路径从 $A$ 到 $B$；
        这里因为 $A$ 和 $B$ 是两个独立的强连通分量，那么不可能又存在路径从 $B$ 到 $A$。
    
    综上，如果 Tosaraju先后生成了两个强连通分量 $A$ 和 $B$，那么一定不存在路径从 $B$ 到 $A$。

## Tarjan 算法

Targan 算法只需要一次 dfs 就可以找到有向图的强连通分量。

我们仔细分析一下在一轮 dfs 中的过程。

1. 对于任何一个强连通分量 U , 整轮 dfs 一定会访问到这个强连通分量 U ，我们设强连通分量U里最先被访问到的节点为 u0 。那么，根据强连通分量的性质，我们可以肯定，强连通分量 U 的剩余节点一定是在以节点 u0 为根的 dfs 生成树中(如果以 u0 为根的 dfs 生成树上不包含所有的强连通分量 U 的节点，那么就表示 U 上存在 u0 点无法到达的节点，那么 U 就不是强连通分量)。

2. 不同的 dfs 生成树上的节点一定在不同的强连通分量中。而对于同一棵 dfs 生成树 T 上的节点 u, 我们需要确定这个节点 u 是否是它所在强连通分量 U 中，被首次访问到的节点 u0。那我们就分析一下这个节点 u 为根的 dfs 生成子树中的特点：
    
    - 如果生成子树中存在节点 n 能够到达 u 的祖上节点 m，那么 n、u 和 m 互相强连通，它们一定在同一个强连通分量中，也就是说 u 不是 u0。
    - 如果生成子树中不存在节点(包括 u 它自己) 能够到达 u 的祖上节点，那么 u 一定是 u0。这里表示 u 和 u 所能到达的所有节点都不能访问到能到达 u 的节点，那么 u 的祖上节点和 u 一定不在同一个强连通分量中。(这里隐含一个递归性，大家需要思考一下)

那么 Tarjan 算法的流程为：

- 输入一张有向图 $G$；
- 使用 dfs 策略来搜索图，可以用栈来记录dfs森林的访问, 也需要对节点从小到大编号。
- 我们递归求解每个节点能到达的最早的祖上节点(同一棵生成树)，这里指编号最小的祖上节点。
  这里每访问到一个节点，就将它压入栈中。
- 如果节点 u 最早能到达的祖上节点就是它本身，那么它就是这个强连通分量的代表节点 u0。
  这时，我们可以把栈中的元素一一弹出，直到弹到 u，所有弹出的元素构成一个强连通分量。

我们可以确定，同一棵 dfs 生成树中弹出的强连通分量是满足逆拓扑排序的，但是我们并没有手段来维护 dfs 生成森林弹出的强连通分量的拓扑排序。